// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package data

import (
	//	"fmt"
	"errors"
)

type ndfloat64 struct {
	ndfloat64Common
	Impl []float64
}

// func (nd *ndfloat64) getUnderlying(i int) float64 {
// 	return nd.Impl[i]
// }

// func (nd *ndfloat64) setUnderlying(i int, v float64) {
// 	nd.Impl[i] = v
// }

// func (nd *ndfloat64) takeImplementation(other ndfloat64) error {
// like, err := other.(*ndfloat64)
// 	if !err {
// 		return errors.New("Can't take implementation...")
// 	}
// 	nd.Impl = like.Impl
// 	return nil
// }

func (nd *ndfloat64) Get(loc []int) float64 {
	return nd.Impl[nd.Index(loc)]
}

func (nd *ndfloat64) Set(loc []int, val float64) {
	nd.Impl[nd.Index(loc)] = val
}

func (nd *ndfloat64) Slice(loc []int, dims []int, step []int) NDFloat64 {
	result := ndfloat64{}
	nd.slice(&result.ndfloat64Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *ndfloat64) Apply(loc []int, dim int, step int, vals []float64) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	slice := nd.Slice(loc, sliceDim, sliceStep)

	if slice.Contiguous() {
		concrete := slice.(*ndfloat64)
		implSlice := concrete.Impl
		subset := implSlice[concrete.Start : concrete.Start+len(vals)]
		copy(subset, vals)
	} else {
		start := loc[dim]
		for i, v := range vals {
			loc[dim] = start + i*step
			nd.Set(loc, v)
		}
		loc[dim] = start
	}
}

func (nd *ndfloat64) ApplySlice(loc []int, step []int, vals NDFloat64) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)
	if slice.Contiguous() {
		copy(slice.Unroll(), vals.Unroll())
		return
	}

	idx := slice.NewIndex(0)
	size := product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		increment(idx, shape)
	}
	// How to speed up
}

func (nd *ndfloat64) Unroll() []float64 {
	if nd.Contiguous() {
		s := nd.Start
		e := nd.Index(decrement(nd.Dims))
		return nd.Impl[s : e+1]
	}

	//	fmt.Println(nd)

	length := product(nd.Shape())
	res := make([]float64, length)

	dimOffsets := offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := idivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *ndfloat64) ReshapeFast(newShape []int) (NDFloat64, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *ndfloat64) Reshape(newShape []int) (NDFloat64, error) {
	result := ndfloat64{}
	size := product(newShape)
	currentSize := product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = 0
		result.Impl = nd.Unroll()
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = ones(len(newShape))

		result.Offset = offsets(newShape)
		return &result, nil
	}

	seriesDim := argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	return &result, nil
}

func (nd *ndfloat64) MustReshape(newShape []int) NDFloat64 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *ndfloat64) Get1(loc int) float64 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *ndfloat64) Set1(loc int, val float64) {
	nd.Set([]int{loc}, val)
}

func (nd *ndfloat64) Apply1(loc int, step int, vals []float64) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *ndfloat64) Get2(loc1 int, loc2 int) float64 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *ndfloat64) Set2(loc1 int, loc2 int, val float64) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *ndfloat64) Get3(loc1 int, loc2 int, loc3 int) float64 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *ndfloat64) Set3(loc1 int, loc2 int, loc3 int, val float64) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func NewArrayFloat64(dims []int) NDFloat64 {
	return newArrayfloat64(dims)
}

func newArrayfloat64(dims []int) *ndfloat64 {
	result := ndfloat64{}
	size := product(dims)
	result.Start = 0
	result.Impl = make([]float64, size)
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = ones(len(dims))
	result.Offset = offsets(dims)
	return &result
}

func NewArray1DFloat64(dim int) ND1Float64 {
	return newArrayfloat64([]int{dim})
}

func NewArray2DFloat64(dim1 int, dim2 int) ND2Float64 {
	return newArrayfloat64([]int{dim1, dim2})
}

func NewArray3DFloat64(dim1 int, dim2 int, dim3 int) ND3Float64 {
	return newArrayfloat64([]int{dim1, dim2, dim3})
}

func ARangeFloat64(n int) NDFloat64 {
	arr := NewArrayFloat64([]int{n})
	idx := arr.NewIndex(0)
	for i := 0; i < n; i++ {
		idx[0] = i
		arr.Set(idx, float64(i))
	}
	return arr
}

type ndfloat32 struct {
	ndfloat32Common
	Impl []float32
}

// func (nd *ndfloat32) getUnderlying(i int) float64 {
// 	return nd.Impl[i]
// }

// func (nd *ndfloat32) setUnderlying(i int, v float64) {
// 	nd.Impl[i] = v
// }

// func (nd *ndfloat32) takeImplementation(other ndfloat32) error {
// like, err := other.(*ndfloat32)
// 	if !err {
// 		return errors.New("Can't take implementation...")
// 	}
// 	nd.Impl = like.Impl
// 	return nil
// }

func (nd *ndfloat32) Get(loc []int) float32 {
	return nd.Impl[nd.Index(loc)]
}

func (nd *ndfloat32) Set(loc []int, val float32) {
	nd.Impl[nd.Index(loc)] = val
}

func (nd *ndfloat32) Slice(loc []int, dims []int, step []int) NDFloat32 {
	result := ndfloat32{}
	nd.slice(&result.ndfloat32Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *ndfloat32) Apply(loc []int, dim int, step int, vals []float32) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	slice := nd.Slice(loc, sliceDim, sliceStep)

	if slice.Contiguous() {
		concrete := slice.(*ndfloat32)
		implSlice := concrete.Impl
		subset := implSlice[concrete.Start : concrete.Start+len(vals)]
		copy(subset, vals)
	} else {
		start := loc[dim]
		for i, v := range vals {
			loc[dim] = start + i*step
			nd.Set(loc, v)
		}
		loc[dim] = start
	}
}

func (nd *ndfloat32) ApplySlice(loc []int, step []int, vals NDFloat32) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)
	if slice.Contiguous() {
		copy(slice.Unroll(), vals.Unroll())
		return
	}

	idx := slice.NewIndex(0)
	size := product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		increment(idx, shape)
	}
	// How to speed up
}

func (nd *ndfloat32) Unroll() []float32 {
	if nd.Contiguous() {
		s := nd.Start
		e := nd.Index(decrement(nd.Dims))
		return nd.Impl[s : e+1]
	}

	//	fmt.Println(nd)

	length := product(nd.Shape())
	res := make([]float32, length)

	dimOffsets := offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := idivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *ndfloat32) ReshapeFast(newShape []int) (NDFloat32, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *ndfloat32) Reshape(newShape []int) (NDFloat32, error) {
	result := ndfloat32{}
	size := product(newShape)
	currentSize := product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = 0
		result.Impl = nd.Unroll()
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = ones(len(newShape))

		result.Offset = offsets(newShape)
		return &result, nil
	}

	seriesDim := argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	return &result, nil
}

func (nd *ndfloat32) MustReshape(newShape []int) NDFloat32 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *ndfloat32) Get1(loc int) float32 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *ndfloat32) Set1(loc int, val float32) {
	nd.Set([]int{loc}, val)
}

func (nd *ndfloat32) Apply1(loc int, step int, vals []float32) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *ndfloat32) Get2(loc1 int, loc2 int) float32 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *ndfloat32) Set2(loc1 int, loc2 int, val float32) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *ndfloat32) Get3(loc1 int, loc2 int, loc3 int) float32 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *ndfloat32) Set3(loc1 int, loc2 int, loc3 int, val float32) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func NewArrayFloat32(dims []int) NDFloat32 {
	return newArrayfloat32(dims)
}

func newArrayfloat32(dims []int) *ndfloat32 {
	result := ndfloat32{}
	size := product(dims)
	result.Start = 0
	result.Impl = make([]float32, size)
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = ones(len(dims))
	result.Offset = offsets(dims)
	return &result
}

func NewArray1DFloat32(dim int) ND1Float32 {
	return newArrayfloat32([]int{dim})
}

func NewArray2DFloat32(dim1 int, dim2 int) ND2Float32 {
	return newArrayfloat32([]int{dim1, dim2})
}

func NewArray3DFloat32(dim1 int, dim2 int, dim3 int) ND3Float32 {
	return newArrayfloat32([]int{dim1, dim2, dim3})
}

func ARangeFloat32(n int) NDFloat32 {
	arr := NewArrayFloat32([]int{n})
	idx := arr.NewIndex(0)
	for i := 0; i < n; i++ {
		idx[0] = i
		arr.Set(idx, float32(i))
	}
	return arr
}

type ndint32 struct {
	ndint32Common
	Impl []int32
}

// func (nd *ndint32) getUnderlying(i int) float64 {
// 	return nd.Impl[i]
// }

// func (nd *ndint32) setUnderlying(i int, v float64) {
// 	nd.Impl[i] = v
// }

// func (nd *ndint32) takeImplementation(other ndint32) error {
// like, err := other.(*ndint32)
// 	if !err {
// 		return errors.New("Can't take implementation...")
// 	}
// 	nd.Impl = like.Impl
// 	return nil
// }

func (nd *ndint32) Get(loc []int) int32 {
	return nd.Impl[nd.Index(loc)]
}

func (nd *ndint32) Set(loc []int, val int32) {
	nd.Impl[nd.Index(loc)] = val
}

func (nd *ndint32) Slice(loc []int, dims []int, step []int) NDInt32 {
	result := ndint32{}
	nd.slice(&result.ndint32Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *ndint32) Apply(loc []int, dim int, step int, vals []int32) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	slice := nd.Slice(loc, sliceDim, sliceStep)

	if slice.Contiguous() {
		concrete := slice.(*ndint32)
		implSlice := concrete.Impl
		subset := implSlice[concrete.Start : concrete.Start+len(vals)]
		copy(subset, vals)
	} else {
		start := loc[dim]
		for i, v := range vals {
			loc[dim] = start + i*step
			nd.Set(loc, v)
		}
		loc[dim] = start
	}
}

func (nd *ndint32) ApplySlice(loc []int, step []int, vals NDInt32) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)
	if slice.Contiguous() {
		copy(slice.Unroll(), vals.Unroll())
		return
	}

	idx := slice.NewIndex(0)
	size := product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		increment(idx, shape)
	}
	// How to speed up
}

func (nd *ndint32) Unroll() []int32 {
	if nd.Contiguous() {
		s := nd.Start
		e := nd.Index(decrement(nd.Dims))
		return nd.Impl[s : e+1]
	}

	//	fmt.Println(nd)

	length := product(nd.Shape())
	res := make([]int32, length)

	dimOffsets := offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := idivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *ndint32) ReshapeFast(newShape []int) (NDInt32, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *ndint32) Reshape(newShape []int) (NDInt32, error) {
	result := ndint32{}
	size := product(newShape)
	currentSize := product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = 0
		result.Impl = nd.Unroll()
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = ones(len(newShape))

		result.Offset = offsets(newShape)
		return &result, nil
	}

	seriesDim := argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	return &result, nil
}

func (nd *ndint32) MustReshape(newShape []int) NDInt32 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *ndint32) Get1(loc int) int32 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *ndint32) Set1(loc int, val int32) {
	nd.Set([]int{loc}, val)
}

func (nd *ndint32) Apply1(loc int, step int, vals []int32) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *ndint32) Get2(loc1 int, loc2 int) int32 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *ndint32) Set2(loc1 int, loc2 int, val int32) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *ndint32) Get3(loc1 int, loc2 int, loc3 int) int32 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *ndint32) Set3(loc1 int, loc2 int, loc3 int, val int32) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func NewArrayInt32(dims []int) NDInt32 {
	return newArrayint32(dims)
}

func newArrayint32(dims []int) *ndint32 {
	result := ndint32{}
	size := product(dims)
	result.Start = 0
	result.Impl = make([]int32, size)
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = ones(len(dims))
	result.Offset = offsets(dims)
	return &result
}

func NewArray1DInt32(dim int) ND1Int32 {
	return newArrayint32([]int{dim})
}

func NewArray2DInt32(dim1 int, dim2 int) ND2Int32 {
	return newArrayint32([]int{dim1, dim2})
}

func NewArray3DInt32(dim1 int, dim2 int, dim3 int) ND3Int32 {
	return newArrayint32([]int{dim1, dim2, dim3})
}

func ARangeInt32(n int) NDInt32 {
	arr := NewArrayInt32([]int{n})
	idx := arr.NewIndex(0)
	for i := 0; i < n; i++ {
		idx[0] = i
		arr.Set(idx, int32(i))
	}
	return arr
}

type nduint32 struct {
	nduint32Common
	Impl []uint32
}

// func (nd *nduint32) getUnderlying(i int) float64 {
// 	return nd.Impl[i]
// }

// func (nd *nduint32) setUnderlying(i int, v float64) {
// 	nd.Impl[i] = v
// }

// func (nd *nduint32) takeImplementation(other nduint32) error {
// like, err := other.(*nduint32)
// 	if !err {
// 		return errors.New("Can't take implementation...")
// 	}
// 	nd.Impl = like.Impl
// 	return nil
// }

func (nd *nduint32) Get(loc []int) uint32 {
	return nd.Impl[nd.Index(loc)]
}

func (nd *nduint32) Set(loc []int, val uint32) {
	nd.Impl[nd.Index(loc)] = val
}

func (nd *nduint32) Slice(loc []int, dims []int, step []int) NDUint32 {
	result := nduint32{}
	nd.slice(&result.nduint32Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *nduint32) Apply(loc []int, dim int, step int, vals []uint32) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	slice := nd.Slice(loc, sliceDim, sliceStep)

	if slice.Contiguous() {
		concrete := slice.(*nduint32)
		implSlice := concrete.Impl
		subset := implSlice[concrete.Start : concrete.Start+len(vals)]
		copy(subset, vals)
	} else {
		start := loc[dim]
		for i, v := range vals {
			loc[dim] = start + i*step
			nd.Set(loc, v)
		}
		loc[dim] = start
	}
}

func (nd *nduint32) ApplySlice(loc []int, step []int, vals NDUint32) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)
	if slice.Contiguous() {
		copy(slice.Unroll(), vals.Unroll())
		return
	}

	idx := slice.NewIndex(0)
	size := product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		increment(idx, shape)
	}
	// How to speed up
}

func (nd *nduint32) Unroll() []uint32 {
	if nd.Contiguous() {
		s := nd.Start
		e := nd.Index(decrement(nd.Dims))
		return nd.Impl[s : e+1]
	}

	//	fmt.Println(nd)

	length := product(nd.Shape())
	res := make([]uint32, length)

	dimOffsets := offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := idivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *nduint32) ReshapeFast(newShape []int) (NDUint32, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *nduint32) Reshape(newShape []int) (NDUint32, error) {
	result := nduint32{}
	size := product(newShape)
	currentSize := product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = 0
		result.Impl = nd.Unroll()
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = ones(len(newShape))

		result.Offset = offsets(newShape)
		return &result, nil
	}

	seriesDim := argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	return &result, nil
}

func (nd *nduint32) MustReshape(newShape []int) NDUint32 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *nduint32) Get1(loc int) uint32 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *nduint32) Set1(loc int, val uint32) {
	nd.Set([]int{loc}, val)
}

func (nd *nduint32) Apply1(loc int, step int, vals []uint32) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *nduint32) Get2(loc1 int, loc2 int) uint32 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *nduint32) Set2(loc1 int, loc2 int, val uint32) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *nduint32) Get3(loc1 int, loc2 int, loc3 int) uint32 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *nduint32) Set3(loc1 int, loc2 int, loc3 int, val uint32) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func NewArrayUint32(dims []int) NDUint32 {
	return newArrayuint32(dims)
}

func newArrayuint32(dims []int) *nduint32 {
	result := nduint32{}
	size := product(dims)
	result.Start = 0
	result.Impl = make([]uint32, size)
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = ones(len(dims))
	result.Offset = offsets(dims)
	return &result
}

func NewArray1DUint32(dim int) ND1Uint32 {
	return newArrayuint32([]int{dim})
}

func NewArray2DUint32(dim1 int, dim2 int) ND2Uint32 {
	return newArrayuint32([]int{dim1, dim2})
}

func NewArray3DUint32(dim1 int, dim2 int, dim3 int) ND3Uint32 {
	return newArrayuint32([]int{dim1, dim2, dim3})
}

func ARangeUint32(n int) NDUint32 {
	arr := NewArrayUint32([]int{n})
	idx := arr.NewIndex(0)
	for i := 0; i < n; i++ {
		idx[0] = i
		arr.Set(idx, uint32(i))
	}
	return arr
}

type ndint64 struct {
	ndint64Common
	Impl []int64
}

// func (nd *ndint64) getUnderlying(i int) float64 {
// 	return nd.Impl[i]
// }

// func (nd *ndint64) setUnderlying(i int, v float64) {
// 	nd.Impl[i] = v
// }

// func (nd *ndint64) takeImplementation(other ndint64) error {
// like, err := other.(*ndint64)
// 	if !err {
// 		return errors.New("Can't take implementation...")
// 	}
// 	nd.Impl = like.Impl
// 	return nil
// }

func (nd *ndint64) Get(loc []int) int64 {
	return nd.Impl[nd.Index(loc)]
}

func (nd *ndint64) Set(loc []int, val int64) {
	nd.Impl[nd.Index(loc)] = val
}

func (nd *ndint64) Slice(loc []int, dims []int, step []int) NDInt64 {
	result := ndint64{}
	nd.slice(&result.ndint64Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *ndint64) Apply(loc []int, dim int, step int, vals []int64) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	slice := nd.Slice(loc, sliceDim, sliceStep)

	if slice.Contiguous() {
		concrete := slice.(*ndint64)
		implSlice := concrete.Impl
		subset := implSlice[concrete.Start : concrete.Start+len(vals)]
		copy(subset, vals)
	} else {
		start := loc[dim]
		for i, v := range vals {
			loc[dim] = start + i*step
			nd.Set(loc, v)
		}
		loc[dim] = start
	}
}

func (nd *ndint64) ApplySlice(loc []int, step []int, vals NDInt64) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)
	if slice.Contiguous() {
		copy(slice.Unroll(), vals.Unroll())
		return
	}

	idx := slice.NewIndex(0)
	size := product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		increment(idx, shape)
	}
	// How to speed up
}

func (nd *ndint64) Unroll() []int64 {
	if nd.Contiguous() {
		s := nd.Start
		e := nd.Index(decrement(nd.Dims))
		return nd.Impl[s : e+1]
	}

	//	fmt.Println(nd)

	length := product(nd.Shape())
	res := make([]int64, length)

	dimOffsets := offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := idivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *ndint64) ReshapeFast(newShape []int) (NDInt64, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *ndint64) Reshape(newShape []int) (NDInt64, error) {
	result := ndint64{}
	size := product(newShape)
	currentSize := product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = 0
		result.Impl = nd.Unroll()
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = ones(len(newShape))

		result.Offset = offsets(newShape)
		return &result, nil
	}

	seriesDim := argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	return &result, nil
}

func (nd *ndint64) MustReshape(newShape []int) NDInt64 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *ndint64) Get1(loc int) int64 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *ndint64) Set1(loc int, val int64) {
	nd.Set([]int{loc}, val)
}

func (nd *ndint64) Apply1(loc int, step int, vals []int64) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *ndint64) Get2(loc1 int, loc2 int) int64 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *ndint64) Set2(loc1 int, loc2 int, val int64) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *ndint64) Get3(loc1 int, loc2 int, loc3 int) int64 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *ndint64) Set3(loc1 int, loc2 int, loc3 int, val int64) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func NewArrayInt64(dims []int) NDInt64 {
	return newArrayint64(dims)
}

func newArrayint64(dims []int) *ndint64 {
	result := ndint64{}
	size := product(dims)
	result.Start = 0
	result.Impl = make([]int64, size)
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = ones(len(dims))
	result.Offset = offsets(dims)
	return &result
}

func NewArray1DInt64(dim int) ND1Int64 {
	return newArrayint64([]int{dim})
}

func NewArray2DInt64(dim1 int, dim2 int) ND2Int64 {
	return newArrayint64([]int{dim1, dim2})
}

func NewArray3DInt64(dim1 int, dim2 int, dim3 int) ND3Int64 {
	return newArrayint64([]int{dim1, dim2, dim3})
}

func ARangeInt64(n int) NDInt64 {
	arr := NewArrayInt64([]int{n})
	idx := arr.NewIndex(0)
	for i := 0; i < n; i++ {
		idx[0] = i
		arr.Set(idx, int64(i))
	}
	return arr
}

type nduint64 struct {
	nduint64Common
	Impl []uint64
}

// func (nd *nduint64) getUnderlying(i int) float64 {
// 	return nd.Impl[i]
// }

// func (nd *nduint64) setUnderlying(i int, v float64) {
// 	nd.Impl[i] = v
// }

// func (nd *nduint64) takeImplementation(other nduint64) error {
// like, err := other.(*nduint64)
// 	if !err {
// 		return errors.New("Can't take implementation...")
// 	}
// 	nd.Impl = like.Impl
// 	return nil
// }

func (nd *nduint64) Get(loc []int) uint64 {
	return nd.Impl[nd.Index(loc)]
}

func (nd *nduint64) Set(loc []int, val uint64) {
	nd.Impl[nd.Index(loc)] = val
}

func (nd *nduint64) Slice(loc []int, dims []int, step []int) NDUint64 {
	result := nduint64{}
	nd.slice(&result.nduint64Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *nduint64) Apply(loc []int, dim int, step int, vals []uint64) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	slice := nd.Slice(loc, sliceDim, sliceStep)

	if slice.Contiguous() {
		concrete := slice.(*nduint64)
		implSlice := concrete.Impl
		subset := implSlice[concrete.Start : concrete.Start+len(vals)]
		copy(subset, vals)
	} else {
		start := loc[dim]
		for i, v := range vals {
			loc[dim] = start + i*step
			nd.Set(loc, v)
		}
		loc[dim] = start
	}
}

func (nd *nduint64) ApplySlice(loc []int, step []int, vals NDUint64) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)
	if slice.Contiguous() {
		copy(slice.Unroll(), vals.Unroll())
		return
	}

	idx := slice.NewIndex(0)
	size := product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		increment(idx, shape)
	}
	// How to speed up
}

func (nd *nduint64) Unroll() []uint64 {
	if nd.Contiguous() {
		s := nd.Start
		e := nd.Index(decrement(nd.Dims))
		return nd.Impl[s : e+1]
	}

	//	fmt.Println(nd)

	length := product(nd.Shape())
	res := make([]uint64, length)

	dimOffsets := offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := idivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *nduint64) ReshapeFast(newShape []int) (NDUint64, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *nduint64) Reshape(newShape []int) (NDUint64, error) {
	result := nduint64{}
	size := product(newShape)
	currentSize := product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = 0
		result.Impl = nd.Unroll()
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = ones(len(newShape))

		result.Offset = offsets(newShape)
		return &result, nil
	}

	seriesDim := argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	return &result, nil
}

func (nd *nduint64) MustReshape(newShape []int) NDUint64 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *nduint64) Get1(loc int) uint64 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *nduint64) Set1(loc int, val uint64) {
	nd.Set([]int{loc}, val)
}

func (nd *nduint64) Apply1(loc int, step int, vals []uint64) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *nduint64) Get2(loc1 int, loc2 int) uint64 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *nduint64) Set2(loc1 int, loc2 int, val uint64) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *nduint64) Get3(loc1 int, loc2 int, loc3 int) uint64 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *nduint64) Set3(loc1 int, loc2 int, loc3 int, val uint64) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func NewArrayUint64(dims []int) NDUint64 {
	return newArrayuint64(dims)
}

func newArrayuint64(dims []int) *nduint64 {
	result := nduint64{}
	size := product(dims)
	result.Start = 0
	result.Impl = make([]uint64, size)
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = ones(len(dims))
	result.Offset = offsets(dims)
	return &result
}

func NewArray1DUint64(dim int) ND1Uint64 {
	return newArrayuint64([]int{dim})
}

func NewArray2DUint64(dim1 int, dim2 int) ND2Uint64 {
	return newArrayuint64([]int{dim1, dim2})
}

func NewArray3DUint64(dim1 int, dim2 int, dim3 int) ND3Uint64 {
	return newArrayuint64([]int{dim1, dim2, dim3})
}

func ARangeUint64(n int) NDUint64 {
	arr := NewArrayUint64([]int{n})
	idx := arr.NewIndex(0)
	for i := 0; i < n; i++ {
		idx[0] = i
		arr.Set(idx, uint64(i))
	}
	return arr
}
