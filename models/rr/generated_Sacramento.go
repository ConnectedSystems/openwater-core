package rr

/* WARNING: GENERATED CODE
 *
 * This file is generated by ow-specgen using metadata from src/github.com/flowmatters/openwater-core/models/rr/sacramento.go
 * 
 * Don't edit this file. Edit src/github.com/flowmatters/openwater-core/models/rr/sacramento.go instead!
 */
import (
//  "fmt"
  "github.com/flowmatters/openwater-core/sim"
  "github.com/flowmatters/openwater-core/data"
)


type Sacramento struct {
  lzpk data.ND1Float64
  lzsk data.ND1Float64
  uzk data.ND1Float64
  uztwm data.ND1Float64
  uzfwm data.ND1Float64
  lztwm data.ND1Float64
  lzfsm data.ND1Float64
  lzfpm data.ND1Float64
  pfree data.ND1Float64
  rexp data.ND1Float64
  zperc data.ND1Float64
  side data.ND1Float64
  ssout data.ND1Float64
  pctim data.ND1Float64
  adimp data.ND1Float64
  sarva data.ND1Float64
  rserv data.ND1Float64
  uh1 data.ND1Float64
  uh2 data.ND1Float64
  uh3 data.ND1Float64
  uh4 data.ND1Float64
  uh5 data.ND1Float64
  
}

func (m *Sacramento) ApplyParameters(parameters data.ND2Float64) {
  // fmt.Println(parameters)
  // fmt.Println(parameters.Shape())
  nSets := parameters.Len(sim.DIMP_CELL)
  // fmt.Println(nSets)
  m.lzpk = parameters.Slice([]int{ 0, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.lzsk = parameters.Slice([]int{ 1, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.uzk = parameters.Slice([]int{ 2, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.uztwm = parameters.Slice([]int{ 3, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.uzfwm = parameters.Slice([]int{ 4, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.lztwm = parameters.Slice([]int{ 5, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.lzfsm = parameters.Slice([]int{ 6, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.lzfpm = parameters.Slice([]int{ 7, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.pfree = parameters.Slice([]int{ 8, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.rexp = parameters.Slice([]int{ 9, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.zperc = parameters.Slice([]int{ 10, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.side = parameters.Slice([]int{ 11, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.ssout = parameters.Slice([]int{ 12, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.pctim = parameters.Slice([]int{ 13, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.adimp = parameters.Slice([]int{ 14, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.sarva = parameters.Slice([]int{ 15, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.rserv = parameters.Slice([]int{ 16, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.uh1 = parameters.Slice([]int{ 17, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.uh2 = parameters.Slice([]int{ 18, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.uh3 = parameters.Slice([]int{ 19, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.uh4 = parameters.Slice([]int{ 20, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  m.uh5 = parameters.Slice([]int{ 21, 0}, []int{ 1, nSets}, nil).(data.ND1Float64)
  
}


func buildSacramento() sim.TimeSteppingModel {
	result := Sacramento{}
	return &result
}

func init() {
	sim.Catalog["Sacramento"] = buildSacramento
}

func (m *Sacramento)  Description() sim.ModelDescription{
	var result sim.ModelDescription
	result.Parameters = []sim.ParameterDescription{
  
  sim.DescribeParameter("lzpk",0,""),
  sim.DescribeParameter("lzsk",0,""),
  sim.DescribeParameter("uzk",0,""),
  sim.DescribeParameter("uztwm",0,""),
  sim.DescribeParameter("uzfwm",0,""),
  sim.DescribeParameter("lztwm",0,""),
  sim.DescribeParameter("lzfsm",0,""),
  sim.DescribeParameter("lzfpm",0,""),
  sim.DescribeParameter("pfree",0,""),
  sim.DescribeParameter("rexp",0,""),
  sim.DescribeParameter("zperc",0,""),
  sim.DescribeParameter("side",0,""),
  sim.DescribeParameter("ssout",0,""),
  sim.DescribeParameter("pctim",0,""),
  sim.DescribeParameter("adimp",0,""),
  sim.DescribeParameter("sarva",0,""),
  sim.DescribeParameter("rserv",0,""),
  sim.DescribeParameter("uh1",0,""),
  sim.DescribeParameter("uh2",0,""),
  sim.DescribeParameter("uh3",0,""),
  sim.DescribeParameter("uh4",0,""),
  sim.DescribeParameter("uh5",0,""),}

  result.Inputs = []string{
  "rainfall","pet",}
  result.Outputs = []string{
  "runoff","imperviousRunoff","surfaceRunoff","interflow","baseflow",}

  result.States = []string{
  "UprTensionWater","UprFreeWater","LwrTensionWater","LwrPrimaryFreeWater","LwrSupplFreeWater","AdditionalImperviousStore",}

	return result
}




func (m *Sacramento) InitialiseStates(n int) data.ND2Float64 {
  // Zero states
	var result = data.NewArray2DFloat64(n,6)

	// for i := 0; i < n; i++ {
  //   stateSet := make(sim.StateSet,6)
  //   
	// 	stateSet[0] = 0 // UprTensionWater
  //   
	// 	stateSet[1] = 0 // UprFreeWater
  //   
	// 	stateSet[2] = 0 // LwrTensionWater
  //   
	// 	stateSet[3] = 0 // LwrPrimaryFreeWater
  //   
	// 	stateSet[4] = 0 // LwrSupplFreeWater
  //   
	// 	stateSet[5] = 0 // AdditionalImperviousStore
  //   

  //   if result==nil {
  //     result = data.NewArray2DFloat64(stateSet.Len(0),n)
  //   }
  //   result.Apply([]int{0,i},[]int{1,1},stateSet)
	// }
 
	return result
}



func (m *Sacramento) Run(inputs data.ND3Float64, states data.ND2Float64, outputs data.ND3Float64) {

  // Loop over all cells
  inputDims := inputs.Shape()
  numCells := states.Len(sim.DIMS_CELL)
  numStates := states.Len(sim.DIMS_STATE)
  numInputSequences := inputs.Len(sim.DIMI_CELL)

  //  fmt.Println("num cells",lenStates,"num states",numStates)
  // fmt.Println("states shape",states.Shape())
  // fmt.Println("states",states) 
  inputLen := inputDims[sim.DIMI_TIMESTEP]
  cellInputsShape := inputDims[1:]
  inputNewShape := []int{inputLen}

  outputPosSlice := outputs.NewIndex(0)
  outputStepSlice := outputs.NewIndex(1)
  outputSizeSlice := outputs.NewIndex(1)
  outputSizeSlice[sim.DIMO_TIMESTEP] = inputLen

  statesPosSlice := states.NewIndex(0)
  statesSizeSlice := states.NewIndex(1)
  statesSizeSlice[sim.DIMS_STATE] = numStates

  inputsPosSlice := inputs.NewIndex(0)
  inputsSizeSlice := inputs.NewIndex(1)
  inputsSizeSlice[sim.DIMI_INPUT] = inputDims[sim.DIMI_INPUT]
  inputsSizeSlice[sim.DIMI_TIMESTEP] = inputLen

//  var result sim.RunResults
//	result.Outputs = data.NewArray3DFloat64( 5, inputLen, numCells)
//	result.States = states  //clone? make([]sim.StateSet, len(states))

  // fmt.Println("Running Sacramento for ",numCells,"cells")
  for i := 0; i < numCells; i++ {
    outputPosSlice[sim.DIMO_CELL] = i
    statesPosSlice[sim.DIMS_CELL] = i
    inputsPosSlice[sim.DIMI_CELL] = i%numInputSequences

    
    // fmt.Println("lzpk=",m.lzpk)
		lzpk := m.lzpk.Get1(i%m.lzpk.Len1())
    
    // fmt.Println("lzsk=",m.lzsk)
		lzsk := m.lzsk.Get1(i%m.lzsk.Len1())
    
    // fmt.Println("uzk=",m.uzk)
		uzk := m.uzk.Get1(i%m.uzk.Len1())
    
    // fmt.Println("uztwm=",m.uztwm)
		uztwm := m.uztwm.Get1(i%m.uztwm.Len1())
    
    // fmt.Println("uzfwm=",m.uzfwm)
		uzfwm := m.uzfwm.Get1(i%m.uzfwm.Len1())
    
    // fmt.Println("lztwm=",m.lztwm)
		lztwm := m.lztwm.Get1(i%m.lztwm.Len1())
    
    // fmt.Println("lzfsm=",m.lzfsm)
		lzfsm := m.lzfsm.Get1(i%m.lzfsm.Len1())
    
    // fmt.Println("lzfpm=",m.lzfpm)
		lzfpm := m.lzfpm.Get1(i%m.lzfpm.Len1())
    
    // fmt.Println("pfree=",m.pfree)
		pfree := m.pfree.Get1(i%m.pfree.Len1())
    
    // fmt.Println("rexp=",m.rexp)
		rexp := m.rexp.Get1(i%m.rexp.Len1())
    
    // fmt.Println("zperc=",m.zperc)
		zperc := m.zperc.Get1(i%m.zperc.Len1())
    
    // fmt.Println("side=",m.side)
		side := m.side.Get1(i%m.side.Len1())
    
    // fmt.Println("ssout=",m.ssout)
		ssout := m.ssout.Get1(i%m.ssout.Len1())
    
    // fmt.Println("pctim=",m.pctim)
		pctim := m.pctim.Get1(i%m.pctim.Len1())
    
    // fmt.Println("adimp=",m.adimp)
		adimp := m.adimp.Get1(i%m.adimp.Len1())
    
    // fmt.Println("sarva=",m.sarva)
		sarva := m.sarva.Get1(i%m.sarva.Len1())
    
    // fmt.Println("rserv=",m.rserv)
		rserv := m.rserv.Get1(i%m.rserv.Len1())
    
    // fmt.Println("uh1=",m.uh1)
		uh1 := m.uh1.Get1(i%m.uh1.Len1())
    
    // fmt.Println("uh2=",m.uh2)
		uh2 := m.uh2.Get1(i%m.uh2.Len1())
    
    // fmt.Println("uh3=",m.uh3)
		uh3 := m.uh3.Get1(i%m.uh3.Len1())
    
    // fmt.Println("uh4=",m.uh4)
		uh4 := m.uh4.Get1(i%m.uh4.Len1())
    
    // fmt.Println("uh5=",m.uh5)
		uh5 := m.uh5.Get1(i%m.uh5.Len1())
    

    // fmt.Println("i",i)
    // fmt.Println("States",states.Shape())
    // fmt.Println("Tmp2",tmp2.Shape())
    
    initialStates := states.Slice(statesPosSlice,statesSizeSlice,nil).MustReshape([]int{numStates}).(data.ND1Float64)
//    fmt.Println("IS Shape",initialStates.Shape())
//    fmt.Println("IS",initialStates)
//    

    
    
    uprtensionwater := initialStates.Get1(0)
    
    uprfreewater := initialStates.Get1(1)
    
    lwrtensionwater := initialStates.Get1(2)
    
    lwrprimaryfreewater := initialStates.Get1(3)
    
    lwrsupplfreewater := initialStates.Get1(4)
    
    additionalimperviousstore := initialStates.Get1(5)
    
    

//    fmt.Println("is",inputDims,"tmpShape",tmpCI.Shape(),"cis",cellInputsShape)

		cellInputs := inputs.Slice(inputsPosSlice,inputsSizeSlice,nil).MustReshape(cellInputsShape)
//    fmt.Println("cellInputs Shape",cellInputs.Shape())
    
//    fmt.Println("{rainfall mm}",tmpTS.Shape())
		rainfall := cellInputs.Slice([]int{ 0,0}, []int{ 1,inputLen}, nil).MustReshape(inputNewShape).(data.ND1Float64)
    
//    fmt.Println("{pet mm}",tmpTS.Shape())
		pet := cellInputs.Slice([]int{ 1,0}, []int{ 1,inputLen}, nil).MustReshape(inputNewShape).(data.ND1Float64)
    

    

    
    
    outputPosSlice[sim.DIMO_OUTPUT] = 0
    runoff := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
    
    outputPosSlice[sim.DIMO_OUTPUT] = 1
    imperviousrunoff := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
    
    outputPosSlice[sim.DIMO_OUTPUT] = 2
    surfacerunoff := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
    
    outputPosSlice[sim.DIMO_OUTPUT] = 3
    interflow := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
    
    outputPosSlice[sim.DIMO_OUTPUT] = 4
    baseflow := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
    
    

		uprtensionwater,uprfreewater,lwrtensionwater,lwrprimaryfreewater,lwrsupplfreewater,additionalimperviousstore= sacramento(rainfall,pet,uprtensionwater,uprfreewater,lwrtensionwater,lwrprimaryfreewater,lwrsupplfreewater,additionalimperviousstore,lzpk,lzsk,uzk,uztwm,uzfwm,lztwm,lzfsm,lzfpm,pfree,rexp,zperc,side,ssout,pctim,adimp,sarva,rserv,uh1,uh2,uh3,uh4,uh5,runoff,imperviousrunoff,surfacerunoff,interflow,baseflow)

    
    
    initialStates.Set1(0, uprtensionwater)
    
    initialStates.Set1(1, uprfreewater)
    
    initialStates.Set1(2, lwrtensionwater)
    
    initialStates.Set1(3, lwrprimaryfreewater)
    
    initialStates.Set1(4, lwrsupplfreewater)
    
    initialStates.Set1(5, additionalimperviousstore)
    
    

//		result.Outputs.ApplySpice([]int{i,0,0},[]int = make([]sim.Series, 5)
    
	}

//	return result
}
